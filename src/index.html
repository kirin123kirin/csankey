<!DOCTYPE html>
<html lang="ja">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Sankey Diagram</title>

  <style>
    h1 {
      position: relative;
      /* padding: 0.1em 0.5em; */
      background: -webkit-linear-gradient(to right, gray, transparent);
      background: linear-gradient(to right, gray, transparent);
      color: white;
    }

    body {
      font-family: "MS UI Gothic";
    }

    rect {
      shape-rendering: crispEdges;
    }

    text {
      font-size: 18px;
      font-family: "MS UI Gothic";
    }

    .node-label {
      font-size: 18px;
      font-family: "メイリオ", "Meiryo";
      font-weight: bold;
      fill: blue;
    }

    .link-label {
      font-size: 16px;
      font-family: "MS UI Gothic";
      fill: white;
      font-size: 14px;
      font-style: italic;
    }

    .link-label-rect {
      fill: blue;
      opacity: 100%;
    }

    .link {
      fill: none;
    }

    svg {
      /* position: absolute; */
      top: 0;
      left: 0;
      pointer-events: all;
    }

    .toggle_area {
      position: relative;
      /* margin: auto; */
      width: 50px;
      height: 25px;
      float: left;
    }

    .toggle_area input[type="radio"] {
      display: none;
    }

    .toggle_area label {
      display: block;
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      line-height: 20px;
      font-size: 10pt;
      font-weight: bold;
      border: 2px solid #ccc;
    }

    .toggle_area #R1_ON+label,
    #R2_ON+label,
    #R3_ON+label {
      right: 50%;
      border-radius: 6px 0 0 6px;
      background: #eee;
      color: #666;
      border-right: none;
    }

    .toggle_area #R1_ON:checked+label,
    #R2_ON:checked+label,
    #R3_ON:checked+label {
      background: linear-gradient(180deg, #00b359, #006633, #00b359);
      color: #fff;
      text-shadow: 1px 1px 1px #333;
    }

    .toggle_area #R1_OFF+label,
    #R2_OFF+label,
    #R3_OFF+label {
      left: 50%;
      border-radius: 0 6px 6px 0;
      background: #eee;
      color: #666;
      border-left: none;
    }

    .toggle_area #R1_OFF:checked+label,
    #R2_OFF:checked+label,
    #R3_OFF:checked+label {
      background: linear-gradient(175deg, #ccc, #999, #ccc);
      color: #fff;
      text-shadow: 1px 1px 1px #333;
    }

    footer {
      width: 100%;
      font-size: 9px;
      background-color: gray;
      color: #fff;
      text-align: left;
      padding: 5px 0;

      /* position: absolute; */
      bottom: 0;
    }
  </style>



  <!-- include Section -->
  <script src="d3.v4.min.js"></script>
  <script src="d3-sankey-circular.js"></script>



  <!-- My Script Section -->
  <script>
    let margin = { top: 30, right: 30, bottom: 30, left: 30 };
    let width = 1100;
    let height = 600;

    let nodePadding = 40;
    var circularLinkGap = 2;

    let sankey = null;
    let svg = null;
    let g = null;
    let linkLabels = null;
    let linkG = null;
    let nodeG = null;
    let nodeColour = null;
    let node = null;
    let link = null;
    let arrowsG = null;
    let animateDash = null;
    let sankeyData = null;
    let sankeyNodes = null;
    let sankeyLinks = null;
    let depthExtent = null;
    let linkpathes = null;
    let duration = 5
    let maxOffset = 10
    let percentageOffset = 1.0

    let re_markdownlink = /(!?)\[\s*([^\]]*)\s*\]\(\s*["']*([^\) "]*)["']*\s*\)/gu;

    // Function that appends a path to selection that has sankey path data attached
    // The path is formatted as dash array, and triangle paths to create arrows along the path
    function appendArrows(selection, arrowLength, gapLength, arrowHeadSize) {
      let totalDashArrayLength = arrowLength + gapLength

      arrows = selection
        .append('path')
        .attr('d', function (d) {
          return d.path;
        })
        .style('stroke-width', 1)
        .style('stroke', 'black')
        .style('stroke-dasharray', arrowLength + ',' + gapLength)

      arrows.each(function (arrow) {
        let thisPath = d3.select(this).node()
        let parentG = d3.select(this.parentNode)
        let pathLength = thisPath.getTotalLength()
        let numberOfArrows = Math.ceil(pathLength / totalDashArrayLength)

        // remove the last arrow head if it will overlap the target node
        if (
          (numberOfArrows - 1) * totalDashArrayLength +
          (arrowLength + (arrowHeadSize + 1)) >
          pathLength
        ) {
          numberOfArrows = numberOfArrows - 1
        }

        let arrowHeadData = d3.range(numberOfArrows).map(function (d, i) {
          let length = i * totalDashArrayLength + arrowLength

          let point = thisPath.getPointAtLength(length)
          let previousPoint = thisPath.getPointAtLength(length - 2)

          let rotation = 0

          if (point.y == previousPoint.y) {
            rotation = point.x < previousPoint.x ? 180 : 0
          } else if (point.x == previousPoint.x) {
            rotation = point.y < previousPoint.y ? -90 : 90
          } else {
            let adj = Math.abs(point.x - previousPoint.x)
            let opp = Math.abs(point.y - previousPoint.y)
            let angle = Math.atan(opp / adj) * (180 / Math.PI)
            if (point.x < previousPoint.x) {
              angle = angle + (90 - angle) * 2
            }
            if (point.y < previousPoint.y) {
              rotation = -angle
            } else {
              rotation = angle
            }
          }

          return { x: point.x, y: point.y, rotation: rotation }
        })

        let arrowHeads = parentG
          .selectAll('.arrow-heads')
          .data(arrowHeadData)
          .enter()
          .append('path')
          .attr('d', function (d) {
            return (
              'M' +
              d.x + ',' +
              (d.y - arrowHeadSize / 2) +
              ' L' +
              (d.x + arrowHeadSize) + ',' +
              d.y +
              ' L' +
              d.x + ',' +
              (d.y + arrowHeadSize / 2)
            )
          })
          .attr('class', 'arrow-head')
          .attr('transform', function (d) {
            return 'rotate(' + d.rotation + ',' + d.x + ',' + d.y + ')'
          })
          .style('fill', 'black')
      })
    }

    function addMinardLabels(link) {
      let thisLength = 1
      let position = this.getPointAtLength(thisLength)
      let positionPlueOne = this.getPointAtLength(thisLength + 5)

      // let adj = positionPlueOne.x - position.x;
      // let opp = position.y - positionPlueOne.y;
      // let angle = Math.atan(opp / adj) * (180 / Math.PI);
      let rotation = 0;

      let label = node
      let result = re_markdownlink.exec(link.value)

      if (result) {
        link.value = link.value.replace(re_markdownlink, result[2])
        if (result[1] == "!")
          label = node.append("img").attr("src", result[3]).attr("alt", link.value)
        else
          label = node.append("a").attr("xlink:href", result[3])
      }

      let clen = String(link.value).length;

      /* thanks for https://stackoverflow.com/questions/6725288/svg-text-inside-rect */
      label.append("rect")
        .attr("class", "link-label-rect")
        .attr("x", position.x)
        .attr("y", position.y - 23)
        .attr("rx", 4)
        .attr("ry", 4)
        .attr("height", 25)
        .attr("width", 25 + (clen * (2.6 - (clen / 100))) * Math.log(clen))

      label.append("text")
        .attr("class", "link-label")
        .attr("x", position.x)
        .attr("y", position.y - 5)
        .attr("dx", "0.2em")
        .style("text-anchor", "start")
        .attr("transform", "rotate(" + rotation + "," + position.x + "," + position.y + ")")
        .text(link.value)

    }

    function download_PNG() {
      var svg = document.querySelector("svg");
      var svgData = new XMLSerializer().serializeToString(svg);
      var canvas = document.createElement("canvas");

      let height = document.F1.T1[1].value;
      let width = document.F1.T1[0].value;
      canvas.width = svg.width.baseVal.value;
      canvas.height = svg.height.baseVal.value;

      var ctx = canvas.getContext("2d");
      var image = new Image;
      image.onload = function () {

        if (width && height)
          ctx.drawImage(image, 0, 0, width, height);
        else if (width)
          ctx.drawImage(image, 0, 0, width, canvas.height);
        else if (height)
          ctx.drawImage(image, 0, 0, canvas.width, height);
        else
          ctx.drawImage(image, 0, 0);

        var a = document.createElement("a");
        a.href = canvas.toDataURL("image/png");
        a.setAttribute("download", "sankeydiagram.png");
        a.dispatchEvent(new MouseEvent("click"));
      }
      image.src = "data:image/svg+xml;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(svgData)));
    }

    function highlightNodes(node, name) {

      let opacity = 0.3

      if (node.name == name) {
        opacity = 1;
      }
      node.sourceLinks.forEach(function (link) {
        if (link.target.name == name) {
          opacity = 1;
        };
      })
      node.targetLinks.forEach(function (link) {
        if (link.source.name == name) {
          opacity = 1;
        };
      })

      return opacity;

    }

    function leftLinebreak(data) {
      let text = data.name
      if (text.indexOf('\n') == -1)
        return text

      let array = text.replace("\r", "").split("\n")
      if (array.length < 2)
        return text

      let ret = "";

      array.forEach((t, i) => {
        let adjast_x = data.x0 + t.length * 5
        let adjast_y = (data.y0 - (array.length - 1) * 35) + (i * 25)
        ret += `<tspan y="${adjast_y}" x="${adjast_x}">${t}</tspan>`;
      });
      return ret;
    }

    function rightLinebreak(textdata) { //@todo
      let array = textdata.split("\n")
      let string = "";
      const maxTextLength = d3.max(array, d => d.length)
      array.forEach((t, i) => {
        let l = maxTextLength - t.length;
        string += `<tspan y="${i}em" x="${l}em">${t}</tspan>`;
      });
      return string;
    }

    function centerLinebreak(textdata) { //@todo
      let array = textdata.split("\n")
      let string = "";
      const maxTextLength = d3.max(array, d => d.length)
      array.forEach((t, i) => {
        let l = (maxTextLength - t.length) / 2;
        string += `<tspan y="${i}em" x="${l}em">${t}</tspan>`;
      });
      return string
    }


    /* My Handling Section */

    function initialize() {
      if (sankey)
        d3.selectAll("svg").remove()

      sankey = d3.sankeyCircular()
        .nodeWidth(10)
        .nodePadding(nodePadding) //note that this will be overridden by nodePaddingRatio
        .nodePaddingRatio(0.5)
        .size([width, height])
        .nodeId(function (d) {
          return d.name;
        })
        .nodeAlign(d3.sankeyJustify)
        .iterations(32)
        .circularLinkGap(2);

      svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

      g = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      linkG = g.append("g")
        .attr("class", "links")
        .attr("fill", "none")
        .attr("stroke-opacity", 0.2)
        .selectAll("path");

      nodeG = g.append("g")
        .attr("class", "nodes")
        .attr("font-family", "sans-serif")
        .attr("font-size", 10)
        .selectAll("g");

      //run the Sankey + circular over the data
      sankeyData = sankey(data);
      sankeyNodes = sankeyData.nodes;
      sankeyLinks = sankeyData.links;

      // console.log(sankeyLinks);

      depthExtent = d3.extent(sankeyNodes, function (d) { return d.depth; });

      nodeColour = d3.scaleSequential(d3.interpolateCool)
        .domain([0, width]);
    }

    function nodes_setup() {
      node = nodeG.data(sankeyNodes)
        .enter()
        .append("g");

      node.append("rect")
        .attr("class", "node-rect")
        .attr("x", function (d) { return d.x0; })
        .attr("y", function (d) { return d.y0; })
        .attr("height", function (d) { return d.y1 - d.y0; })
        .attr("width", function (d) { return d.x1 - d.x0; })
        .style("fill", function (d) { return nodeColour(d.x0); })
        .style("opacity", 0.5)
        .on("mouseover", function (d) {

          let thisName = d.name;

          node.selectAll(".node-rect")
            .style("opacity", function (d) {
              return highlightNodes(d, thisName)
            })

          d3.selectAll(".sankey-link")
            .style("opacity", function (l) {
              return l.source.name == thisName || l.target.name == thisName ? 1 : 0.3;
            })

          link.selectAll(".link-label-rect")
            .style("opacity", function (l) {
              console.log(l)
              return l.source.name == thisName || l.target.name == thisName ? 1 : 0.3;
            })

          node.selectAll("text")
            .style("opacity", function (d) {
              return highlightNodes(d, thisName)
            })
        })
        .on("mouseout", function (d) {
          d3.selectAll(".node-rect").style("opacity", 0.5);
          d3.selectAll(".link-label-rect").style("opacity", 1);
          d3.selectAll(".sankey-link").style("opacity", 0.7);
          d3.selectAll("text").style("opacity", 1);
        })

      let nodelabel = node.append("text")
        .attr("class", "node-label")
        .attr("x", function (d) { return (d.x0 + d.x1) / 2; })
        .attr("y", function (d) { return d.y0 - 20; })
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")

      nodelabel.append("a").attr("xlink:href", function (d) {
        var result = re_markdownlink.exec(d.name)
        if (result) {
          d.name = d.name.replace(re_markdownlink, result[2])
          return result[3];
        }
        return null
      }).style("text-decoration", "underline")
        .html(function (d) { return leftLinebreak(d) }) //LF thanks for https://gunmagisgeek.com/blog/d3v4/4686

      node.append("title")
        .text(function (d) { return d.name + "\n" + (d.value); });

    }

    function links_setup() {
      link = linkG.data(sankeyLinks)
        .enter()
        .append("g")

      linkpathes = link.append("path")
        .attr("class", "sankey-link")
        .attr("d", function (link) {
          return link.path;
        })
        .style("stroke-width", function (d) { return Math.max(1, d.width); })
        .style("opacity", 0.7)
        .style("stroke", function (link, i) {
          return link.circular ? "red" : "black"
        })

      link.append("title")
        .text(function (d) {
          return d.source.name + " → " + d.target.name;
        });
    }

    //VALUES
    function value_on() {
      linkpathes.each(addMinardLabels);
    }

    //ARROWS
    function arrows_initialize() {
      arrowsG = linkG.data(sankeyLinks)
        .enter()
        .append("g")
        .attr("class", "g-arrow")
        .call(appendArrows, 50, 100, 10) //arrow length, gap, arrow head size
    }

    function arrow_on() {
      arrowsG.selectAll(".arrow-head")
        .attr("markerWidth", "0")
        .style('fill', 'gray')
    }

    function arrow_off() {
      arrowsG.selectAll(".arrow-head").remove()
    }

    function updateDash() {
      arrowsG.selectAll("path")
        .style("stroke-dashoffset", percentageOffset * maxOffset)

      percentageOffset = percentageOffset <= 0.0 ? 10 : percentageOffset - 0.01
    }

    function animation_on() {
      arrowsG.selectAll("path")
        .style("stroke-width", "5")
        .style("stroke-dasharray", "10,40")

      if (animateDash == null)
        animateDash = setInterval(updateDash, duration);
    }

    function animation_off() {
      arrowsG.selectAll("path")
        .style("stroke-width", "0")
    }

    /* Startup Handling Section */

    function func() {
      initialize()
      nodes_setup()
      links_setup()
      arrows_initialize()

      if (document.f_animation.R1[0].checked) {
        animation_on()
      } else {
        animation_off()
      }

      if (document.f_arrow.R2[0].checked) {
        arrow_on()
      } else {
        arrow_off()
      }

      if (document.f_value.R3[0].checked) {
        value_on()
      }

    }

  </script>



  <!-- My Sankey Data Section -->
  <script>
    var data = {
      "nodes": [
        { "name": "abc" },
        { "name": "b\nbb" },
        { "name": "ccc" },
        { "name": "aaa" },
      ],
      "links": [
        { "source": "b\nbb", "target": "abc", "value": 1 },
        { "source": "ccc", "target": "aaa", "value": 1 },
        { "source": "abc", "target": "b\nbb", "value": 1 },
        { "source": "b\nbb", "target": "ccc", "value": 1 },
        { "source": "aaa", "target": "b\nbb", "value": 1 },
      ]
    };
  </script>


</head>

<body>

  <h1>Sankey Diagram Output Page</h1>

  <div>

    <table>
      <tr>
        <td>アニメーション</td>
        <td>
          <form class="toggle_area" name="f_animation" action="#">
            <input type="radio" name="R1" id="R1_ON" onclick="func()" checked="checked">
            <label for="R1_ON">入</label>
            <input type="radio" name="R1" id="R1_OFF" onclick="func()">
            <label for="R1_OFF">切</label>
          </form>
        </td>
        <td>&nbsp</td>

        <td>矢印</td>
        <td>
          <form class="toggle_area" name="f_arrow" action="#">
            <input type="radio" name="R2" id="R2_ON" onclick="func()" checked="checked">
            <label for="R2_ON">入</label>
            <input type="radio" name="R2" id="R2_OFF" onclick="func()">
            <label for="R2_OFF">切</label>
          </form>
        </td>
        <td>&nbsp</td>

        <td>値表示</td>
        <td>
          <form class="toggle_area" name="f_value" action="#">
            <input type="radio" name="R3" id="R3_ON" onclick="func()" checked="checked">
            <label for="R3_ON">入</label>
            <input type="radio" name="R3" id="R3_OFF" onclick="func()">
            <label for="R3_OFF">切</label>
          </form>
        </td>
        <td>&nbsp</td>

        <td>
          <form name="F1" action="#">
            <div>
              &nbsp;<input type="text" name="T1" size="3" maxlength="4" placeholder="幅pixel"
                oninput="value = value.replace(/[^0-9]+/i,'');" title="空白の場合は等倍解像度でダウンロード">
              &nbsp;<input type="text" name="T1" size="3" maxlength="4" placeholder="高pixel"
                oninput="value = value.replace(/[^0-9]+/i,'');" title="空白の場合は等倍解像度でダウンロード">&nbsp;
            </div>
            <div>
              <!-- thanks for download button data http://design-ec.com/?p=342 -->
              &nbsp;<input type="button" src="pngdownload.png" value="PNGダウンロード" onclick="download_PNG()">
            </div>
          </form>
        </td>
      </tr>
    </table>

  </div>

  <div id="chart"></div>
  <script>func()</script>
  
  <div><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>
  <div>
    <footer><a href="https://bl.ocks.org/tomshanley/874923fe54b173735b456479423ac7d6">[Referenced by Sankey
        with circular link and animated dashes]</a></footer>
  </div>
</body>

</html>
