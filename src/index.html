<!DOCTYPE html>
<html lang="ja">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Sankey</title>

  <style>
    body {
      font-family: "MS UI Gothic";
    }

    h1 {
      position: relative;
      padding: 0.1em 0.5em;
      background: -webkit-linear-gradient(to right, gray, transparent);
      background: linear-gradient(to right, gray, transparent);
      color: white;
      text-shadow: 1px 1px black;
    }

    footer {
      width: 100%;
      font-size: 9px;
      background: -webkit-linear-gradient(to right, gray, transparent);
      background: linear-gradient(to right, gray, transparent);
      color: #fff;
      text-align: left;
      padding: 5px 0;

      /* position: absolute; */
      bottom: 0;
    }

    .viewsetting {
      width: 900px;
      display: table;
      border-collapse: collapse;
      /* background: -webkit-linear-gradient(to right, gray, transparent);
      background: linear-gradient(to right, gray, transparent); */
      /* color: white; */
      text-align: center;
      text-shadow: 1px 1px #050505;
      font-size: 14px;
      font-family: "メイリオ", "Meiryo";
    }

    .viewsetting .horizon {
      display: table-cell;
      vertical-align: middle;
    }

    rect {
      shape-rendering: crispEdges;
    }

    text {
      font-size: 18px;
      font-family: "MS UI Gothic";
    }

    .node-label {
      font-size: 18px;
      font-family: "メイリオ", "Meiryo";
      font-weight: bold;
      fill: blue;
    }

    .link-label {
      font-size: 16px;
      font-family: "MS UI Gothic";
      fill: white;
      font-style: italic;
    }

    .link {
      fill: none;
    }

    svg {
      /* position: absolute; */
      /* top: 0; */
      /* left: 0; */
      pointer-events: all;
    }


    .segmented_header {
      margin-top: 5px;
      text-align: center;
      height: 10px;
    }

    /*
     * thanks for https://ginpen.com/2012/12/11/segmented-control
     */
    .segmented {
      display: inline-block;
      padding: 10px;
    }

    .segmented .label {
      background-color: #eee;
      background-image: linear-gradient(to bottom, hsl(0, 0%, 98%) 0%, hsl(0, 0%, 77%) 100%);
      border: 1px #ccc;
      border-style: solid none solid solid;
      color: #777;
      cursor: pointer;
      float: left;
      padding: 4px;
      text-align: center;
      text-shadow: 1px 1px #fff;
      /* width: 40px; */
    }

    .segmented :first-child .label {
      border-radius: 5px 0 0 5px;
      /* border-radius: 5px 5px 5px 5px; */
    }

    .segmented :last-child .label {
      border-radius: 0 5px 5px 0;
      /* border-radius: 5px 5px 5px 5px; */
      border-right-style: solid;
    }

    .segmented input {
      display: none;
    }

    .segmented input:checked+.label {
      background-color: #00f;
      background-image: linear-gradient(to bottom, hsl(214, 90%, 40%) 0%, hsl(214, 90%, 70%) 100%);
      border-color: hsl(214, 90%, 60%);
      box-shadow: 3px 2px 10px rgba(0, 0, 0, .2) inset, -3px 2px 10px rgba(0, 0, 0, .2) inset;
      color: #fff;
      text-shadow: -1px -1px rgba(0, 0, 0, .3);
    }

    .segmented .label {
      background-image: -moz-linear-gradient(top, hsl(0, 0%, 98%) 0%, hsl(0, 0%, 77%) 100%);
      background-image: -ms-linear-gradient(top, hsl(0, 0%, 98%) 0%, hsl(0, 0%, 77%) 100%);
      background-image: -webkit-linear-gradient(top, hsl(0, 0%, 98%) 0%, hsl(0, 0%, 77%) 100%);
      background-image: linear-gradient(to bottom, hsl(0, 0%, 98%) 0%, hsl(0, 0%, 77%) 100%);
    }

    .segmented input:checked+span,
    [download] span {
      background-image: -moz-linear-gradient(top, hsl(214, 90%, 40%) 0%, hsl(214, 90%, 70%) 100%);
      background-image: -ms-linear-gradient(top, hsl(214, 90%, 40%) 0%, hsl(214, 90%, 70%) 100%);
      background-image: -webkit-linear-gradient(top, hsl(214, 90%, 40%) 0%, hsl(214, 90%, 70%) 100%);
      background-image: -webkit-linear-gradient(to bottom, hsl(214, 90%, 40%) 0%, hsl(214, 90%, 70%) 100%);
    }

    /* 
     * thanks for https://devsnap.me/css-download-buttons
     */
    [download] {
      background: none;
      /* 		border: solid 1px #e6e6e6; */
      border-radius: 3px;
      display: inline-block;
      height: 65px;
      line-height: 65px;
      /* margin: 5px; */
      position: relative;
      text-align: center;
      vertical-align: middle;
      width: 80px;
    }

    [download] span {
      /* background: orange; */
      border-radius: 4px;
      color: #ffffff;
      display: inline-block;
      font-size: 11px;
      font-weight: 700;
      line-height: normal;
      padding: 5px 10px;
      position: relative;
      text-transform: uppercase;
      z-index: 1;
    }

    [download] span:last-child {
      margin-left: -20px;
    }

    [download]:before,
    [download]:after {
      background: #ffffff;
      border: solid 3px #9fb4cc;
      border-radius: 4px;
      content: '';
      display: block;
      height: 35px;
      left: 50%;
      margin: -17px 0 0 -12px;
      position: absolute;
      top: 50%;
      /*transform:translate(-50%,-50%);*/

      width: 25px;
    }

    [download]:hover:before,
    [download]:hover:after {
      background: #e2e8f0;
    }

    /* [download]:before{transform:translate(-30%,-60%);} */

    [download]:before {
      margin: -23px 0 0 -5px;
    }

    [download]:hover {
      background: #e2e8f0;
      border-color: #9fb4cc;
    }

    [download]:active {
      background: #dae0e8;
      box-shadow: inset 0 2px 2px rgba(0, 0, 0, .25);
    }

    [download] span:first-child {
      display: none;
    }

    [download]:hover span:first-child {
      display: inline-block;
    }

    [download]:hover span:last-child {
      display: none;
    }

    /* 
     * thanks for https://codepen.io/rperry1886/pen/OJPQxza
     */
    button {
      filter: drop-shadow(3px 3px 3px rgba(60, 60, 60, 0.432));
      min-height: 25px;
      min-width: 25px;
      background: blue;
      font-weight: bold;
      color: white;
      font-size: 12pt;
      border: none;
      padding: 10;
      stroke: black;
      outline: none;
      border-radius: 10px 10px 10px 10px;
    }

    button:hover {
      filter: drop-shadow(3px 5px 5px rgba(0, 0, 0, 0.45));
    }

    button:active {
      filter: none;
      transform: scale(.95);
    }


    /* 
     * thanks for https://codepen.io/estelle/pen/RJpreX
     */
    table {
      border-collapse: collapse;
      font-family: "メイリオ", "Meiryo";
    }

    td,
    th {
      border: 1px solid;
      padding: 8px;
      min-width: 10px;
      background: white;
      box-sizing: border-box;
      text-align: left;
      padding-right: 5em;
    }

    .table-container {
      position: relative;
      max-height: 500px;
      width: 1000px;
      overflow: scroll;
    }

    thead th {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
      z-index: 2;
      color: azure;
      border-color: black;
      background: hsl(214, 90%, 40%);
    }

    thead th:first-child {
      color: black;
      left: 0;
      z-index: 3;
    }

    tfoot {
      position: -webkit-sticky;
      bottom: 0;
      z-index: 2;
      color: azure;
      border-color: black;
    }

    tfoot td {
      position: sticky;
      bottom: 0;
      z-index: 2;
      background: hsl(214, 90%, 40%);
    }

    tfoot td:first-child {
      z-index: 3;
      color: black;
    }

    tbody {
      overflow: scroll;
      height: 500px;
    }

    /* MAKE LEFT COLUMN FIXEZ */
    tr> :first-child {
      position: -webkit-sticky;
      position: sticky;
      background: hsl(214, 90%, 70%);
      left: 0;
    }

    /* don't do this */
    tr> :first-child {
      box-shadow: inset 0px 1px black;
    }
  </style>



  <!-- include Section -->
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="d3-sankey-circular.js"></script>


  <!-- My Script Section -->
  <script>
    let margin = { top: 30, right: 30, bottom: 30, left: 30 };
    let width = 1100;
    let height = 600;

    let nodePadding = 40;
    var circularLinkGap = 2;

    let sankey = null;
    let svg = null;
    let g = null;
    let linkLabels = null;
    let linkG = null;
    let nodeG = null;
    let nodeColour = null;
    let node = null;
    let link = null;
    let arrowsG = null;
    let animateDash = null;
    let sankeyData = null;
    let sankeyNodes = null;
    let sankeyLinks = null;
    let depthExtent = null;
    let linkpathes = null;
    let duration = 5
    let maxOffset = 10
    let percentageOffset = 1.0

    let re_markdownlink = /(!?)\[\s*([^\]]*)\s*\]\(\s*["']*([^\) "]*)["']*\s*\)/gu;

    // Function that appends a path to selection that has sankey path data attached
    // The path is formatted as dash array, and triangle paths to create arrows along the path
    function appendArrows(selection, arrowLength, gapLength, arrowHeadSize) {
      let totalDashArrayLength = arrowLength + gapLength

      arrows = selection
        .append('path')
        .attr('d', function (d) {
          return d.path;
        })
        .style('stroke-width', 1)
        .style('stroke', 'black')
        .style('stroke-dasharray', arrowLength + ',' + gapLength)

      arrows.each(function (arrow) {
        let thisPath = d3.select(this).node()
        let parentG = d3.select(this.parentNode)
        let pathLength = thisPath.getTotalLength()
        let numberOfArrows = Math.ceil(pathLength / totalDashArrayLength)

        // remove the last arrow head if it will overlap the target node
        if (
          (numberOfArrows - 1) * totalDashArrayLength +
          (arrowLength + (arrowHeadSize + 1)) >
          pathLength
        ) {
          numberOfArrows = numberOfArrows - 1
        }

        let arrowHeadData = d3.range(numberOfArrows).map(function (d, i) {
          let length = i * totalDashArrayLength + arrowLength

          let point = thisPath.getPointAtLength(length)
          let previousPoint = thisPath.getPointAtLength(length - 2)

          let rotation = 0

          if (point.y == previousPoint.y) {
            rotation = point.x < previousPoint.x ? 180 : 0
          } else if (point.x == previousPoint.x) {
            rotation = point.y < previousPoint.y ? -90 : 90
          } else {
            let adj = Math.abs(point.x - previousPoint.x)
            let opp = Math.abs(point.y - previousPoint.y)
            let angle = Math.atan(opp / adj) * (180 / Math.PI)
            if (point.x < previousPoint.x) {
              angle = angle + (90 - angle) * 2
            }
            if (point.y < previousPoint.y) {
              rotation = -angle
            } else {
              rotation = angle
            }
          }

          return { x: point.x, y: point.y, rotation: rotation }
        })

        let arrowHeads = parentG
          .selectAll('.arrow-heads')
          .data(arrowHeadData)
          .enter()
          .append('path')
          .attr('d', function (d) {
            return (
              'M' +
              d.x + ',' +
              (d.y - arrowHeadSize / 2) +
              ' L' +
              (d.x + arrowHeadSize) + ',' +
              d.y +
              ' L' +
              d.x + ',' +
              (d.y + arrowHeadSize / 2)
            )
          })
          .attr('class', 'arrow-head')
          .attr('transform', function (d) {
            return 'rotate(' + d.rotation + ',' + d.x + ',' + d.y + ')'
          })
          .style('fill', 'black')
      })
    }

    /* refs https://bl.ocks.org/tomshanley/d01b00c17a5ebe76779c26f82ab9d7ec#index.html */
    function addMinardLabels(link) {
      let position = this.getPointAtLength(3)
      if (!(typeof (link.value) == "string" || link.value instanceof String))
        link.value = String(link.value)

      /* thanks for https://stackoverflow.com/questions/39974264/how-to-pack-text-inside-svg-rect */
      let length = String(link.value).length;
      let count = (link.value.match(/\n/g) || [1]).length;

      g.append("title").text(link.source.name + "→" + link.target.name + " = " + link.value)
      let label = g.append("foreignObject")
        .attr("class", "link-label")
        .attr("_source", link.source.name)
        .attr("_target", link.target.name)
        .attr("x", position.x)
        .attr("y", position.y - 15)
        .attr("width", 32 + (length - 1) * 9)
        .attr("height", count * 32)
        .append("xhtml:div")
        .append("button")
        .attr("type", "button")
        // .attr("title", )

      let result = re_markdownlink.exec(link.value)
      if (result) {
        link.value = link.value.replace(re_markdownlink, result[2])
        label
          .attr("onclick", 'location.href="' + result[3] + '"')
          .style("cursor", "pointer")
      } else {
        label.attr("disabled", false)
      }
      label = label.text(link.value)
    }

    /* thanks for https://qiita.com/Nikkely/items/aa485ebdbec51e49ecbc */
    function getSVGdata(SVGElement = document.querySelector("svg")) {
      SVGElement.version = 1.1
      SVGElement.xmlns = 'http://www.w3.org/2000/svg'

      const queue = []
      queue.push(SVGElement)
      while (queue.length != 0) {
        const element = queue.pop()

        const computedStyle = window.getComputedStyle(element, '')
        for (let property of computedStyle) {
          element.style[property] = computedStyle.getPropertyValue(property)
        }

        const children = element.children

        for (let child of children) {
          queue.push(child)
        }
      }

      return new XMLSerializer().serializeToString(SVGElement);
    }

    /* thanks for https://kuroeveryday.blogspot.com/2016/05/file-download-from-browser.html?m=1 */
    function browser_download(content, mimeType, savefilename) {
      // BOM mojibake
      let bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      let blob = new Blob([bom, content], { type: mimeType });

      let a = document.createElement('a');
      a.download = savefilename;
      a.target = '_blank';

      if (window.navigator.msSaveBlob) {
        // for IE
        window.navigator.msSaveBlob(blob, savefilename)
      }
      else if (window.URL && window.URL.createObjectURL) {
        // for Firefox
        a.href = window.URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }
      else if (window.webkitURL && window.webkitURL.createObject) {
        // for Chrome
        a.href = window.webkitURL.createObjectURL(blob);
        a.click();
      }
      else {
        // for Safari
        window.open('data:' + mimeType + ';charset=utf-8;base64,' + window.Base64.encode(content), '_blank');
      }
    }

    /* thanks for https://zenn.dev/skryo/articles/7d7f1ce601510b */
    function download_PNG() {
      let elem = document.querySelector("svg");
      let svgData = getSVGdata(elem)
      let canvas = document.createElement("canvas");

      let height = document.F1.T1[1].value;
      let width = document.F1.T1[0].value;
      canvas.width = elem.width.baseVal.value;
      canvas.height = elem.height.baseVal.value;

      let ctx = canvas.getContext("2d");
      let image = new Image;
      image.onload = function () {

        if (width && height)
          ctx.drawImage(image, 0, 0, width, height);
        else if (width)
          ctx.drawImage(image, 0, 0, width, canvas.height);
        else if (height)
          ctx.drawImage(image, 0, 0, canvas.width, height);
        else
          ctx.drawImage(image, 0, 0);

        var a = document.createElement("a");
        a.href = canvas.toDataURL("image/png");
        a.setAttribute("download", "sankeydiagram.png");
        a.dispatchEvent(new MouseEvent("click"));
      }
      image.src = "data:image/svg+xml;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(svgData)));

    }

    /* thank you for https://kuroeveryday.blogspot.com/2016/05/file-download-from-browser.html */
    function download_SVG() {
      let elem = document.querySelector("svg");
      browser_download(getSVGdata(elem), 'image/svg+xml', 'sankeydiagram.svg')
    }

    function highlightNodes(node, name) {

      let opacity = 0.3

      if (node.name == name) {
        opacity = 1;
      }
      node.sourceLinks.forEach(function (link) {
        if (link.target.name == name) {
          opacity = 1;
        };
      })
      node.targetLinks.forEach(function (link) {
        if (link.source.name == name) {
          opacity = 1;
        };
      })

      return opacity;

    }

    /* thanks for https://bl.ocks.org/shimizu/44ac0be6f0ce6e75bd62 */
    function leftLinebreak(data) {
      let text = data.name
      if (text.indexOf('\n') == -1)
        return text

      let array = text.replace("\r", "").split("\n")
      let alen = array.length
      if (alen < 2)
        return text

      let ret = "";

      const maxTextLength = d3.max(array, d => d.length)
      const ax = data.x0
      const ay = data.y0
      array.forEach((t, i) => {
        let adjast_x = ax + t.length * 5
        let adjast_y = (ay - (alen - 1) * 35) + (i * 25)
        ret += `<tspan y="${adjast_y}" x="${adjast_x}">${t}</tspan>`;
      });
      return ret;
    }

    function rightLinebreak(data) {
      let text = data.name
      if (text.indexOf('\n') == -1)
        return text

      let array = text.replace("\r", "").split("\n")
      let alen = array.length
      if (alen < 2)
        return text

      let ret = "";

      const maxTextLength = d3.max(array, d => d.length)
      const ax = data.x0
      const ay = data.y0
      array.forEach((t, i) => {
        let adjast_x = ax + (2 * maxTextLength - t.length) * 5
        let adjast_y = (ay - (alen - 1) * 35) + (i * 25)
        ret += `<tspan y="${adjast_y}" x="${adjast_x}">${t}</tspan>`;
      });
      return ret;
    }

    function centerLinebreak(data) {
      let text = data.name
      if (text.indexOf('\n') == -1)
        return text

      let array = text.replace("\r", "").split("\n")
      let alen = array.length
      if (alen < 2)
        return text

      let ret = "";
      const maxTextLength = d3.max(array, d => d.length)
      const ax = data.x0
      const ay = data.y0
      array.forEach((t, i) => {
        let adjast_x = ax + (maxTextLength + t.length) * 2.5
        let adjast_y = (ay - (alen - 1) * 35) + (i * 25)
        ret += `<tspan y="${adjast_y}" x="${adjast_x}">${t}</tspan>`;
      });
      return ret
    }


    /* My Handling Section */

    function initialize() {
      if (sankey)
        d3.selectAll("svg").remove()

      sankey = d3.sankeyCircular()
        .nodeWidth(10)
        .nodePadding(nodePadding) //note that this will be overridden by nodePaddingRatio
        .nodePaddingRatio(0.5)
        .size([width, height])
        .nodeId(function (d) {
          return d.name;
        })
        .nodeAlign(d3.sankeyJustify)
        .iterations(32)
        .circularLinkGap(2);

      svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("xmlns:xlink", "http://www.w3.org/1999/xlink");

      g = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      linkG = g.append("g")
        .attr("class", "links")
        .attr("fill", "none")
        .attr("stroke-opacity", 0.2)
        .selectAll("path");

      nodeG = g.append("g")
        .attr("class", "nodes")
        .attr("font-family", "sans-serif")
        .attr("font-size", 10)
        .selectAll("g");

      //run the Sankey + circular over the data
      sankeyData = sankey(data);
      sankeyNodes = sankeyData.nodes;
      sankeyLinks = sankeyData.links;

      // console.log(sankeyLinks);

      depthExtent = d3.extent(sankeyNodes, function (d) { return d.depth; });

      nodeColour = d3.scaleSequential(d3.interpolateCool)
        .domain([0, width]);
    }

    function nodes_setup() {
      node = nodeG.data(sankeyNodes)
        .enter()
        .append("g");

      node.append("rect")
        .attr("class", "node-rect")
        .attr("x", function (d) { return d.x0; })
        .attr("y", function (d) { return d.y0; })
        .attr("height", function (d) { return d.y1 - d.y0; })
        .attr("width", function (d) { return d.x1 - d.x0; })
        .style("fill", function (d) { return nodeColour(d.x0); })
        .style("opacity", 0.5)
        .on("mouseover", function (d) {

          let thisName = d.name;

          link.selectAll(".sankey-link")
            .style("opacity", function (l) {
              return l.source.name == thisName || l.target.name == thisName ? 1 : 0.3;
            })

          node.selectAll("text, .node-rect")
            .style("opacity", function (d) {
              return highlightNodes(d, thisName)
            })

          node.selectAll(".link-label")
            .style("opacity", function (d) {
              let src = this.attributes[1].nodeValue;
              let tar = this.attributes[2].nodeValue;
              return thisName == src || thisName == tar ? 1 : 0.1;
            })

        })
        .on("mouseout", function (d) {
          d3.selectAll("text").style("opacity", 1);
          d3.selectAll(".node-rect").style("opacity", 0.5);
          d3.selectAll(".link-label").style("opacity", 1);
          d3.selectAll(".sankey-link").style("opacity", 0.7);
        })

      let nodelabel = node.append("text")
        .attr("class", "node-label")
        .attr("x", function (d) { return (d.x0 + d.x1) / 2; })
        .attr("y", function (d) { return d.y0 - 20; })
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")

      let nodeposition = document.f_nodepos.R4.value

      nodelabel.append("a").attr("xlink:href", function (d) {
        var result = re_markdownlink.exec(d.name)
        if (result) {
          d.name = d.name.replace(re_markdownlink, result[2])
          return result[3];
        }
        return null
      }).style("text-decoration", "underline")
        .html(function (d) {
          //LF thanks for https://gunmagisgeek.com/blog/d3v4/4686
          if (nodeposition == "left")
            return leftLinebreak(d)
          else if (nodeposition == "right")
            return rightLinebreak(d)
          else
            return centerLinebreak(d)
        })
      node.append("title")
        .text(function (d) { return d.name + "\n" + (d.value); });

    }

    function links_setup() {
      link = linkG.data(sankeyLinks)
        .enter()
        .append("g")

      linkpathes = link.append("path")
        .attr("class", "sankey-link")
        .attr("d", function (link) {
          return link.path;
        })
        .style("stroke-width", function (d) { return Math.max(1, d.width); })
        .style("opacity", 0.7)
        .style("stroke", function (link, i) {
          return link.circular ? "red" : "black"
        })

      link.append("title")
        .text(function (l) {
          return l.source.name + " → " + l.target.name + " = " + l.value;
        });
    }

    //VALUES
    function value_on() {
      linkpathes.each(addMinardLabels);
    }

    //ARROWS
    function arrows_initialize() {
      arrowsG = linkG.data(sankeyLinks)
        .enter()
        .append("g")
        .attr("class", "g-arrow")
        .call(appendArrows, 50, 100, 10) //arrow length, gap, arrow head size
    }

    function arrow_on() {
      arrowsG.selectAll(".arrow-head")
        .attr("markerWidth", "0")
        .style('fill', 'gray')
    }

    function arrow_off() {
      arrowsG.selectAll(".arrow-head").remove()
    }

    function updateDash() {
      arrowsG.selectAll("path")
        .style("stroke-dashoffset", percentageOffset * maxOffset)

      percentageOffset = percentageOffset <= 0.0 ? 10 : percentageOffset - 0.01
    }

    function animation_on() {
      arrowsG.selectAll("path")
        .style("stroke-width", "5")
        .style("stroke-dasharray", "10,40")

      if (animateDash == null)
        animateDash = setInterval(updateDash, duration);
    }

    function animation_off() {
      arrowsG.selectAll("path")
        .style("stroke-width", "0")
    }

    /* Startup Handling Section */

    function func() {
      initialize()
      nodes_setup()
      links_setup()
      arrows_initialize()

      if (document.f_animation.R1[0].checked) {
        animation_on()
      } else {
        animation_off()
      }

      if (document.f_arrow.R2[0].checked) {
        arrow_on()
      } else {
        arrow_off()
      }

      if (document.f_value.R3[0].checked) {
        value_on()
      }

    }

  </script>



  <!-- My Sankey Data Section -->
  <script>
    var data = {
      "nodes": [
        { "name": "abc" },
        { "name": "b\nbb" },
        { "name": "ccc" },
        { "name": "aaあa" },
      ],
      "links": [
        { "source": "b\nbb", "target": "abc", "value": 1 },
        { "source": "ccc", "target": "aaあa", "value": 1 },
        { "source": "abc", "target": "b\nbb", "value": 1 },
        { "source": "b\nbb", "target": "ccc", "value": 1 },
        { "source": "aaあa", "target": "b\nbb", "value": 1 },
      ]
    };
  </script>


</head>

<body>

  <h1>Sankey Diagram Output Page

    <div class="viewsetting">
      <!-- <div class="horizon" style="padding-left: 10px;">アニメーション</div> -->

      <div class="horizon">
        <div class="segmented_header">アニメーション</div>
        <form class="segmented" name="f_animation" action="#">
          <label><input type="radio" name="R1" value="on" onclick="func()" checked><span class="label">入</span></label>
          <label><input type="radio" name="R1" value="off" onclick="func()"><span class="label">切</span></label>
        </form>
      </div>

      <!-- <div class="horizon" style="padding-left: 10px;"></div> -->
      <div class="horizon">
        <div class="segmented_header">矢印</div>
        <form class="segmented" name="f_arrow" action="#">
          <label><input type="radio" name="R2" value="on" onclick="func()" checked><span class="label">入</span></label>
          <label><input type="radio" name="R2" value="off" onclick="func()"><span class="label">切</span></label>
        </form>
      </div>

      <div class="horizon">
        <div class="segmented_header">値表示</div>
        <form class="segmented" name="f_value" action="#">
          <label><input type="radio" name="R3" value="on" onclick="func()" checked><span class="label">入</span></label>
          <label><input type="radio" name="R3" value="off" onclick="func()"><span class="label">切</span></label>
        </form>
      </div>

      <div class="horizon">
        <div class="segmented_header">ノード文字揃え</div>
        <form class="segmented" name="f_nodepos" action="#">
          <label><input type="radio" name="R4" value="left" onclick="func()" checked><span
              class="label">左</span></label>
          <label><input type="radio" name="R4" value="center" onclick="func()"><span class="label">中</span></label>
          <label><input type="radio" name="R4" value="right" onclick="func()"><span class="label">右</span></label>
        </form>
      </div>

      <div class="horizon" style="padding-left: 15px">
        <form name="F1" action="#">
          <div class="horizon">

            <div>
              <input type="text" name="T1" size="3" maxlength="4" placeholder="幅pixel"
                oninput="value = value.replace(/[^0-9]+/i,'');"
                title="解像度 幅ピクセルを4桁数値で指定します&#13;&#10;PNGのみ設定可&#13;&#10;無指定の場合は原寸大の解像度を自動設定します">
            </div>

            <div>
              <input type="text" name="T1" size="3" maxlength="4" placeholder="高pixel"
                oninput="value = value.replace(/[^0-9]+/i,'');"
                title="解像度 高さピクセルを4桁数値で指定します&#13;&#10;PNGのみ設定可&#13;&#10;無指定の場合は原寸大の解像度を自動設定します">
            </div>
          </div>

          <div class="horizon">
            <a href="javascript:download_PNG();" id="DLPNG" download><span>Download</span><span>PNG</span></a>
            <a href="javascript:download_SVG();" id="DLSVG" download><span>Download</span><span>SVG</span></a>
          </div>

        </form>
      </div>

    </div>
  </h1>

  <div id="chart"></div>

  <script>func()</script>


  <!-- @todo -->
  <!-- thanks for https://codepen.io/estelle/pen/RJpreX -->
  <div class="table-container">
    <h2>リンク一覧</h2>
    <div style="padding: 15px;">
      <table>
        <thead>
          <tr>
            <th>Header</th>
            <th>Header</th>
            <th>Header</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>Column one</th>
            <td>Column two</td>
            <td>Column three</td>
          </tr>
          <tr>
            <th>Column one</th>
            <td>Column two</td>
            <td>Column three</td>
          </tr>
        </tbody>

        <tfoot>
          <tr>
            <td>Footer</td>
            <td>Footer</td>
            <td>Footer</td>
          </tr>
        </tfoot>
      </table>
    </div>
  </div>

  <div class="table-container">
    <h2>ノード一覧</h2>
    <div style="padding: 15px;">
      <table>
        <thead>
          <tr>
            <th>Header</th>
            <th>Header</th>
            <th>Header</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>Column one</th>
            <td>Column two</td>
            <td>Column three</td>
          </tr>
          <tr>
            <th>Column one</th>
            <td>Column two</td>
            <td>Column three</td>
          </tr>
        </tbody>

        <tfoot>
          <tr>
            <td>Footer</td>
            <td>Footer</td>
            <td>Footer</td>
          </tr>
        </tfoot>
      </table>
    </div>
  </div>

  <div><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>

  <div>
    <footer>
      csankey Copyright © 2021 kirin123kirin see <a href="https://opensource.org/licenses/MIT">MIT
        Liscense</a>&nbsp;&nbsp;|
      Powered by &nbsp;<a href="https://d3js.org/d3.v4.min.js">d3.js</a>
      &nbsp;|&nbsp;Referenced by Tom Shanley’s&nbsp;<a
        href="https://bl.ocks.org/tomshanley/raw/6eb025290888935f10b142e4bc576d8d/d3-sankey-circular.js">Sankey circular
        links1</a>
      <a href="https://bl.ocks.org/tomshanley/874923fe54b173735b456479423ac7d6">Sankey circular links2</a>
    </footer>
  </div>
</body>

</html>
